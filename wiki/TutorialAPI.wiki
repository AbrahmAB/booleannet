#summary How to use the programmin interface (API)
=Programming Interface in Synchronous and Asynchronous Modes =

A Boolean Network is a set of boolean variables (nodes) that are updated 
via rules (edges) connecting them. The system evolves by performing updates, 
one iteration has elapsed when all updating rules have been performed once. 
During these updates the system visits different states (_N_ nodes 
have _2^N_ different states).

Different updating methodologies may be used. In _synchronous_ updating one 
only commits the new values for the nodes at the end of
each iteration. In _asynchronous_ updating the new values of the nodes became
active at the moment they are assigned. The update order of the nodes may also be important. This order may be _fixed_, meaning that the order is always the same. It can be _random_ where the nodes are assigned new values in random order in each iteration, and finally it can be _rank-random_ where each node has a rank and within ranks the node order is randomized.

*BooleanNet* is a python library for performing boolean network simulations. 
It provides an easy to use application programming interface (API) for
various simulation related tasks. It can execute instructions written out
in a simple text format and maintains a list of all visited states.

Here is a typical usage that runs 5 iterations:
{{{
import boolean
engine = boolean.Engine( mode='async', text=text )
engine.initialize()
engine.iterate( steps=5 )
}}}

The input data is a text (that can be read from a file) that lists the 
inital conditions for the nodes and the updating rules that affect these nodes. 
Here is an example for what a file might look like::

{{{
#
# initialization of the nodes
#
ABA = ABH1 = ERA1 = AGB1 = True
ERA1 = AGB1 = Random
GRC3 = Random

#
# updating rules
#
1: GPA1* = (S1P or not GCR1) and AGB1
1: Atrboh* = pHc and OST1 and ROP2 and not ABI1
1: H+ATPase* = not ROS and not pHc and not Ca2+c
2: AnionEM* = ((Ca2+c or pHc) and not ABI1 ) or (Ca2+c and pHc)
2: Depolar* = KEV or AnionEM  or (not H+ATPase) or (not KOUT) or Ca2+c
2: CaIM* = (ROS or not ERA1 or not ABH1) and (not Depolar)
... 
}}}

The initialization conditions can be `True/False` or `Random`, 
this latter being a random choice between `True/False`. Multiple assignments
of the form `A = B = Random` are allowed  (note that this example will set `A` and `B` 
to the same random value). It is also possible to set all uninitialized values to
`Random` or any other desired value. This can simplify the files, see later sections (Advanced Usage) 
for how to accomplish this. When run in LPDE mode (Linear Piecewise Differential Equations) we have
the option of specifying other parameters during initialization. Every node of the network
may be characterized by an a triplet of values that correspoind to the 
_inital concentration_, a _decay_ and a _threshold_ (see [TutorialLPDE] for what these parameters mean).
Thus we could also write the inital conditions as:

{{{
ABA = ABH1 = ERA1 = AGB1 = (1, 2, 0.7)
}}}

meaning that the `concentration=1`, `decay=2` and the `threshold=0.7`. 
Both kinds of initializations are accepted for every operating mode. Depending on
the mode (pure boolean or hybrid) the value will be converted the appropriate one, with the following conversions rules:
`True/False` values will be converted to `(1, 1, 0,5)/(0, 1, 0.5)` whereas 
value triplets will be converted to the truth value of _concentration >threshold/decay_.

The updating rules must be specified in the following form::

{{{
rank: target* = rule
}}}
    
The rank is an integer value that represents the order of update (only used in _asynchronous_ mode). Lower ranks will get updated before higher ranks, but within ranks the update order is randomized. The star indicates that this is an update rule rather than
an initialization rule. For synchronous updates the order of updates will follow the order 
in which the rules are listed. During the simulation the engine collects all the states 
that the system has visited. To view the states use:

{{{
for state in engine.states:
    print state
}}}

Each `state` is an object that provides access to the values of each node
either as a dictionary or as attribute. Note that while more convenient the attribute 
access works only for node names that are valid python  identifiers i.e. `state.A` will 
work but `state.Ca+2` will not. Here is an example:

{{{
for state in enigne.states:
    print state.A, state['A'], state['Ca+2']
}}}

Please see the `examples` directory for other many other use cases.

==Advanced Usage==

The library allows the user to override multiple aspects of its operation. For example
one may inspect and alter the values right before setting or using them. This allows for 
additional computations to take place or to make some decisions based on other biological 
or empirical evidence, decisions that do not have a proper boolean representation.

It is also possible to change how the operators themselves work, or make operators 
work differently for different nodes. 

===Advanced Initialization===

Often it is inconvenient or impractical to explicitly initialize all nodes in the input file. 
The library offers the option of passing a custom function to the engine initializer that 
will be called for all nodes that are left uninitalized. This function needs to take one 
parameter and must return a `True/False` value in _sync_ and _async_ modes and a value triplet 
in _lpde_ modes.

{{{
def randomizer( node_name ):
    return random.choice( [True, False] )
 
import boolean
engine = boolean.Engine( mode='async', text=text )
engine.initialize( miss_func=randomizer )
}}}

The example above sets uninitialized nodes to a random state. We are ignoring the 
node name but it would be possible to make use of it i.e. if some genes were more likely 
to start out in a given state.