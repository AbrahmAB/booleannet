#summary Using the library in a hybrid mode.

= Introduction =

The hybrid model solves the boolean rules via _linear piecewise differential equations_. 
In this mode every node in the system will have three continuous variables associated with it a _concentration_, a _decay_, and a _threshold_ . Each node is considered `ON` when its concentration is greater than the threshold. Practically this means that a rule written as:

{{{ 
A = B and C 
}}}

will be solved as a differential equation of the form:

{{{ 
dA/dt = (( conc(B) > threshold(B)) and (conc(C) > threshold(C)) - decay(A) * conc(A) 
}}}

Here the boolean (first) term corresponds to the _regulated synthesis_ while the decay (second) term corresponds to _free (unregulated) dissociation_. The equation leads to the following dynamics for each node:
  
  * when the boolean term is `True` the equation is of the form `dA/dt = 1 - decay * A`
  * when the boolean term is `False` the equation is of the form `dA/dt = - decay * A`

This means that in time we may have either an exponential type increase (to a maximal value of `1/decay`) or an exponential type decrease (to zero) of the concentrations. 

= Usage =

The engine can operate on the same syntax files as the [BooleanAPI boolean mode], although one most likely will need to change the initialization parameters from `True/False` values to triplets like `(1.0, 2.0, 0.5)` corresponding to the actual _concentration_, _decay_ and _threshold_. An automatic conversion will take place if the initialization values correspond to the boolean mode:`True/False` values will be converted to `(1, 1, 0,5)/(0, 1, 0.5)`.Here is a typical use case:

{{{
import boolean

text = """
A = B = (1, 1, 0.5)
C = (0, 1, 0.5)
1: A* = not A 
2: B* = A and B
3: C* = not C
"""

engine = boolean.Engine( text=text, mode='lpde' )
engine.initialize()
engine.iterate( fullt=1, steps=10 )

import pylab
pylab.plot( engine.data['A'] , 'o-' )
pylab.show()
}}}

= Advanced Usage =

There are common circumstances where the default behaviors need to be augmented to account for certain biological knowledge. The software provides great flexibility allowing one to alter all aspects of the process.

First some background on what takes place. Internally the software will dynamically generate Python code to describe the differential equations.It then numerically integrates this generated function with a fourth order [http://en.wikipedia.org/wiki/Runge-Kutta_methods Runge-Kutta method]. To modify the behavior we will need to modify the dynamically generated code.

The way to display the code that was generated pass the `debug=1` parameter to the `iterate` method call like so: `engine.iterate( fullt=1, steps=10, debug=1 )`. This will print the following:

{{{
# dynamically generated code
# abbreviations: c=concentration, d=decay, t=threshold, n=newvalue
# [(0, 'A', (1.0, 1.0, 0.5)), (1, 'B', (1.0, 1.0, 0.5)), (2, 'C', (1.0, 1.0, 0.5))]
c0, d0, t0 = 1.000000, 1.000000, 0.500000/1.000000 # A
c1, d1, t1 = 1.000000, 1.000000, 0.500000/1.000000 # B
c2, d2, t2 = 1.000000, 1.000000, 0.500000/1.000000 # C
x0 = c0, c1, c2
def derivs( x, t):
	c0, c1, c2 = x
	n0, n1, n2 = c0, c1, c2

	#1: A * = not A
	n0 = float(  not  ( c0 > t0 )  ) - d0 * c0

	#2: B * = A and B
	n1 = float(  ( c0 > t0 )  and  ( c1 > t1 )  ) - d1 * c1

	#3: C * = C
	n2 = float(  ( c2 > t2 )  ) - d2 * c2

	return ( n0, n1, n2 ) 
}}}