#summary Using the library in a hybrid mode.

= Introduction =

The hybrid model solves the boolean rules via _linear piecewise differential equations_. 
In this mode every node in the system will have three continuous variables associated with it a _concentration_, a _decay_, and a _threshold_ . Each node is considered `ON` when its concentration is greater than the threshold. Practically this means that a rule written as:

{{{ 
A = B and C 
}}}

will be solved as a differential equation of the form:

{{{ 
dA/dt = (( conc(B) > threshold(B)) and (conc(C) > threshold(C)) - decay(A) * conc(A) 
}}}

Here the boolean (first) term corresponds to the _regulated synthesis_ while the decay (second) term corresponds to _free (unregulated) dissociation_. The equation leads to the following dynamics for each node:
  
  * when the boolean term is `True` the equation is of the form `dA/dt = 1 - decay * A`
  * when the boolean term is `False` the equation is of the form `dA/dt = - decay * A`

This means that in time we may have either an exponential type increase (to a maximal value of `1/decay`) or an exponential type decrease (to zero) of the concentrations. 

= Usage =

The engine can operate on the same syntax files as the [BooleanAPI boolean mode], although one most likely will need to change the initialization parameters from `True/False` values to triplets like `(1.0, 2.0, 0.5)` corresponding to the actual _concentration_, _decay_ and _threshold_. An automatic conversion will take place if the initialization values correspond to the boolean mode:`True/False` values will be converted to `(1, 1, 0,5)/(0, 1, 0.5)`.Here is a typical use case:

{{{
import boolean

text = """
A = B = (1, 1, 0.5)
C = (0, 1, 0.5)
1: A* = not C 
2: B* = A and B
3: C* = B
"""

engine = boolean.Engine( text=text, mode='lpde' )
engine.initialize()
engine.iterate( fullt=1, steps=10 )

import pylab
pylab.plot( engine.data['A'] , 'o-' )
pylab.show()
}}}

= Advanced Usage =

There are common circumstances where the default behaviors need to be augmented to account for certain biological knowledge. The software provides great flexibility allowing one to alter all aspects of the process.

First some background on what takes place. Internally the software will dynamically generate Python code to describe the differential equations.It then numerically integrates this generated function with a fourth order [http://en.wikipedia.org/wiki/Runge-Kutta_methods Runge-Kutta method]. To modify the behavior we will need to modify the dynamically generated code.

To display the code that was dynamically generated pass the `debug=1` parameter to the `iterate` method call like so: `engine.iterate( fullt=1, steps=10, debug=1 )`. This will print a series of instruction that end in the following:

{{{
# dynamically generated code
# abbreviations: c=concentration, d=decay, t=threshold, n=newvalue
# [(0, 'A', (1.0, 1.0, 0.5)), (1, 'B', (1.0, 2.0, 0.5)), (2, 'C', (1.0, 3.0, 0.5))]

c0, d0, t0 = 1.0, 1.0, 0.5 # A
c1, d1, t1 = 1.0, 2.0, 0.5 # B
c2, d2, t2 = 1.0, 3.0, 0.5 # C
x0 = c0, c1, c2

def derivs( x, t):
	c0, c1, c2 = x
	n0, n1, n2 = c0, c1, c2

	#1: A * = not A
	n0 = float(  not  ( c0 > t0 )  ) - d0 * c0

	#2: B * = A and B
	n1 = float(  ( c0 > t0 )  and  ( c1 > t1 )  ) - d1 * c1

	#3: C * = C
	n2 = float(  ( c2 > t2 )  ) - d2 * c2

	return ( n0, n1, n2 ) 
}}}

Compare this file to the original text input. The code above can be understood in the following way. Each node is associated an index, for example the `B` node has the index of `1`. The `c`, `d`, and `t` variables stand for the _concentration_, _decay_ and _threshold_ for the node index that follows the variable, this makes say `t1` is the threshold for node `B`. The `n` variable stands for the new value of the node. To make it easier to keep track of what is going on  each line is also displayed in a commented out form (with the `#` sign, these lines are not executed, are there only to allow one to keep track of what was the original line was).
Code generation can be interacted with in a manner similar to the BooleanAPI. The most important of these is the `OVERRIDE` function that gets called at every node generation.
Here is how one starts out overriding. First create an empty function that is assigned to the engine:

{{{
def override( node, indexer, tokens ):
    return None

engine = Engine( text=text, mode='lpde' )
engine.OVERRIDE = local_override
engine.initialize( missing=helper.initializer( conc, default=(0,1,0.5) )  )
engine.iterate( fullt=FULLT, steps=STEPS, debug=1 )
}}}

then slowly build up the function, while watching how the code is being altered. Let's assume that we want to replace the node `MP` with a hill function (to fully understand this example you need to have read the [HelperFunctions helper functions] as well). THe override code would need to look as follows:

{{{
from boolean import helper

data  = helper.read_parameters( 'compartment.csv')
param = data[0]

def override( node, indexer, tokens ):

    if node == 'MP':
        newval = helper.newval( node, indexer)
        hill   = helper.hill_func( node, indexer, param)
        expr = '%s = %s' % ( newval, hill)
        return expr

    return None
}}}

The code above will replace the piecewise differential equation with a hill function for node MP. The helper functions will automatically extract the right parameters from the csv file, as long as the column naming convention is followed (more on this in the section on [HelperFunctions helper functions].