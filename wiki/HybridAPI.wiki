#summary Using the library in a hybrid mode.

= Introduction =

The hybrid model solves the boolean rules via _linear piecewise differential equations_. 
In this mode every node in the system will have three continuous variables associated with it a _concentration_, a _decay_, and a _threshold_ . Each node is considered `ON` when its concentration is greater than the threshold. Practically this means that a rule written as:

{{{ 
A = B and C 
}}}

will be solved as a differential equation of the form:

{{{ 
dA/dt = (( conc(B) > threshold(B)) and (conc(C) > threshold(C)) - decay(A) * conc(A) 
}}}

Here the boolean (first) term corresponds to the _regulated synthesis_ while the decay (second) term corresponds to _free (unregulated) dissociation_. The equation leads to the following dynamics for each node:
  
  * when the boolean term is `True` the equation is of the form `dA/dt = 1 - decay * A`
  * when the boolean term is `False` the equation is of the form `dA/dt = - decay * A`

This means that in time we may have either an exponential type increase (to a maximal value of `1/decay`) or an exponential type decrease (to zero) of the concentrations. 

= Usage =

The engine can operate on the same syntax files as the [BooleanAPI boolean mode], although one most likely will need to change the initialization parameters from `True/False` values to triplets like `(1.0, 2.0, 0.5)` corresponding to the actual _concentration_, _decay_ and _threshold_. An automatic conversion will take place if the initialization values correspond to the boolean mode:`True/False` values will be converted to `(1, 1, 0,5)/(0, 1, 0.5)`. 
 
Internally the software will dynamically generate Python code to describe the differential equations, then it numerically integrates this generated function through a fourth order [http://en.wikipedia.org/wiki/Runge-Kutta_methods Runge-Kutta method]. Here is a typical use case:

{{{
import boolean

text = """
A = B = (1, 1, 0.5)
C = (0, 1, 0.5)
1: A* = not A 
2: B* = A and B
3: C* = not C
"""

engine = boolean.Engine( text=text, mode='lpde' )
engine.initialize()
engine.iterate( fullt=1, steps=10 )

import pylab
pylab.plot( engine.data['A'] , 'o-' )
pylab.show()
}}}