#summary Using the library in a hybrid mode.

= Introduction =

The hybrid model solves the booelan rules via _linear piecewise differential equations_. 
In this mode every node in the system will have three continous variables associated with it a _concentration_, 
a _threshold_ and a _decay_. Each node is considered `ON` when its concentration is greater than 
the threshold. Practically this means that a rule written as:

{{{ 
A = B and C 
}}}

will be solved as a differential equation of the form:

{{{ 
dA/dt = (( conc(B) > threshold(B)) and (conc(C) > threshold(C)) - decay(A) * conc(A) 
}}}

This leads to the following dynamics for each node:
  
  * when the boolean term is `True` the equation is of the form `dA/dt = 1 - decay * A`
  * when the boolean term is `False` the equation is of the form `dA/dt = - decay * A`

In time we may have either an exponential type increase or an exponential type decrease 
of the concentrations.

= Usage =

The engine can operate on the same syntax files as the [BooleanAPI boolean mode], although one most likely will need to change the initialization parameters from `True/False` values to triplets like `(1.0, 2.0, 0.5)` corresponding to the actual _concentration_, _decay_ and _threshold_. There is an automatic conversion taking place between the operating modes (see the [BooleanAPI boolean tutorial] for the actual rules.

Internally the software will generate Python code to describe the differential equations, then numerically integrates this generated function through a fourth order [http://en.wikipedia.org/wiki/Runge-Kutta_methods Runge-Kutta method]. Here is a typical run scenario:

{{{
import boolean

text = """
A = B = (1, 1, 0.5)
C = (0, 1, 0.5)
1: A* = not A 
2: B* = A and B
3: C* = not C
"""

engine = boolean.Engine( text=text, mode='lpde' )
engine.initialize()
engine.iterate( fullt=1, steps=10 )

import pylab
pylab.plot( engine.data['A'] , 'o-' )
pylab.show()
}}}